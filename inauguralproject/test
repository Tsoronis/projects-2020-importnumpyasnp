{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Inaugural Project"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> **Note the following:** \n",
    "> 1. This is an example of how to structure your **inaugural project**.\n",
    "> 1. Remember the general advice on structuring and commenting your code from [lecture 5](https://numeconcopenhagen.netlify.com/lectures/Workflow_and_debugging).\n",
    "> 1. Remember this [guide](https://www.markdownguide.org/basic-syntax/) on markdown and (a bit of) latex.\n",
    "> 1. Turn on automatic numbering by clicking on the small icon on top of the table of contents in the left sidebar.\n",
    "> 1. The `inauguralproject.py` file includes a function which can be used multiple times in this notebook."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Imports and set magics:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The autoreload extension is already loaded. To reload it, use:\n",
      "  %reload_ext autoreload\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import scipy as sp\n",
    "from scipy import linalg\n",
    "from scipy import optimize\n",
    "from scipy import interpolate\n",
    "import sympy as sm\n",
    "\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "plt.style.use('seaborn-whitegrid')\n",
    "from matplotlib import cm\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import math\n",
    "\n",
    "# autoreload modules when code is run\n",
    "%load_ext autoreload\n",
    "%autoreload 2\n",
    "\n",
    "# local modules\n",
    "import inauguralproject"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "toc-hr-collapsed": true
   },
   "source": [
    "# Question 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Consider a consumer solving the following maximization problem:\n",
    "\n",
    "$$\n",
    "\\begin{aligned}\n",
    "c^\\star, {l}^\\star = \\arg \\max_{c,l} \\log (c) - \\nu\\frac{{l}^{1+\\frac{1}{\\epsilon}}}{{1+\\frac{1}{\\epsilon}}}  \\\\\n",
    " \\text{s.t.}\\\\\n",
    " {x} & = m + wl - [\\tau_{0}wl + \\tau_{1}\\max\\{wl -\\kappa,0\\}]\\\\\n",
    "   c & \\in [0,x]\\\\\n",
    "   l &\\in [0,1]\\\\\n",
    "\\end{aligned}\n",
    "$$\n",
    "\n",
    "**Idea:** is to solve the maximization problem using the packages numpy and scipy where the functions log and optimize is called to help solving the problem. First we choose the parameter values for which we will maximize consumption (c) and labor supply (${l}$). Then we define the constraint which is the total resources and the utility function so that we can define the objective which is to maximize the utility subject to the constraint. Then we call the optimizer where we set the method to bounded and the bounds to (0,1) since $ l \\in [0,1] $. NOTE: since utility is monotonically increasing in consumption $c^\\star={x}$ we set c equal to the constraint in the objective function:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Setting **parameters**:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Setting parameters from:\n",
    "#https://nbviewer.jupyter.org/github/NumEconCopenhagen/lectures-2020/blob/master/projects/InauguralProject.pdf\n",
    "m = 1.0\n",
    "v = 10.0\n",
    "epsilon = 0.3\n",
    "tau_0 = 0.4\n",
    "tau_1 = 0.1\n",
    "kappa = 0.4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Defining **functions**:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "metadata": {},
   "outputs": [],
   "source": [
    "#The constraint function which is the total resources. \n",
    "def constraint(l,w,m,v,tau_0,tau_1,kappa):\n",
    "    return m+w*l-(tau_0*w*l+tau_1*max(w*l-kappa,0))\n",
    "\n",
    "#The utility function.\n",
    "def utility(l,c,w,m,epsilon,tau_0,tau_1,kappa):\n",
    "    return np.log(c)-v*l**(1+1/epsilon)/(1+1/epsilon)\n",
    "\n",
    "#The consumer objective we want to maximize\n",
    "def objective(l,w,m,v,epsilon,tau_0,tau_1,kappa):\n",
    "    c = constraint(l,w,m,v,tau_0,tau_1,kappa)\n",
    "    return -utility(l,c,w,m,epsilon,tau_0,tau_1,kappa)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Calling **solver**:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "l =  0.4000006819648221\n",
      "c =  1.240000340982411\n",
      "u =  0.17158308392555593\n"
     ]
    }
   ],
   "source": [
    "#Calling the solver where we use the optimize function from scipy\n",
    "solution = optimize.minimize_scalar(objective,\n",
    "                                    method='bounded',\n",
    "                                    bounds=(0,1),\n",
    "                                    args = (w,m,v,epsilon,tau_0,tau_1,kappa))\n",
    "\n",
    "#Op\n",
    "l = solution.x\n",
    "c = constraint(l,w,m,v,tau_0,tau_1,kappa)\n",
    "u = utility(l,c,w,m,epsilon,tau_0,tau_1,kappa)\n",
    "\n",
    "#Print the solution\n",
    "print(\"l =  \" + str(l))\n",
    "print(\"c =  \" + str(c))\n",
    "print(\"u =  \" + str(u))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ADD ANSWER."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# code"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ADD ANSWER."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# code"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ADD ANSWER."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# code"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ADD ANSWER."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# code"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Conclusion"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ADD CONCISE CONLUSION."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  },
  "toc-autonumbering": true
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
